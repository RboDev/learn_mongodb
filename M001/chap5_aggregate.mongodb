use("sample_airbnb");

// Find all documents that have Wifi as one of the amenities. Only include price and address in the resulting cursor.
db.listingsAndReviews.find(
    { "amenities": "Wifi" },
    { "price": 1, "address": 1, "_id": 0 }).pretty()

// Using the aggregation framework find all documents that have Wifi as one of the amenities``*. Only include* ``price and address in the resulting cursor.
db.listingsAndReviews.aggregate(
    [
        { "$match": { "amenities": "Wifi" } },
        { "$project": { "price": 1,
                        "address": 1,
                        "_id": 0 }}
    ]).pretty()

// Find one document in the collection and only include the address field in the resulting cursor.
db.listingsAndReviews.findOne({ },{ "address": 1, "_id": 0 })

// Project only the address field value for each document, then group all documents into one document per address.country value.
db.listingsAndReviews.aggregate([ { "$project": { "address": 1, "_id": 0 }},
                                  { "$group": { "_id": "$address.country" }}])

// Project only the address field value for each document,
// then group all documents into one document per address.country value,
// and count one for each document in each group.
db.listingsAndReviews.aggregate([
                                  { "$project": { "address": 1, "_id": 0 }},
                                  { "$group": { "_id": "$address.country",
                                                "count": { "$sum": 1 } } }
                                ])

// What room types are present in the sample_airbnb.listingsAndReviews collection?
use("sample_airbnb")

// db.listingsAndReviews.aggregate([
//     { "$project": {"room_type":1, "_id":0}},
//     { "$group": {"_id":"$room_type"}}
// ])

// in fact project is optional here

db.listingsAndReviews.aggregate([ { "$group": { "_id": "$room_type" } }])


// === .sort().limit() ===
use("sample_training") 

db.zips.find().sort({ "pop": 1 }).limit(1)

db.zips.find({ "pop": 0 }).count()

db.zips.find().sort({ "pop": -1 }).limit(1)

db.zips.find().sort({ "pop": -1 }).limit(10)

db.zips.find().sort({ "pop": 1, "city": -1 })

// ----

// Which of the following commands will return the name and 
// founding year for the 5 oldest companies in the sample_training.companies collection?

use("sample_training")
db.companies.find({ "founded_year": { "$ne": null }},
                  { "name": 1, "founded_year": 1 }
                 ).sort({ "founded_year": 1 }).limit(5)

// In what year was the youngest bike rider from the sample_training.trips collection born?
use("sample_training")
db.trips.find({"birth year":{$gt:0}}).sort({"birth year":-1}).limit(1)

db.trips.find({ "birth year": { "$ne":"" } },
              { "birth year": 1 , "_id":0 }).sort({ "birth year": -1 }).limit(1)

// ==== Indexes : to optimize query performances ====

use sample_training

db.trips.find({ "birth year": 1989 })

db.trips.find({ "start station id": 476 }).sort( { "birth year": 1 } )

db.trips.createIndex({ "birth year": 1 })

db.trips.createIndex({ "start station id": 1, "birth year": 1 })

// ---- Quizz 

// ==== Data Modeling
//
// Rule: data is stored the way that it is used
//       get a idea of waht is stored
//       Think how those data will be queried
//       Data model evolves over time as application evolves

//==== UPSERT = Update+Insert
// allows to test if exists before inserting

// here adds a new measures and create a new doc if more than 48 measures in that doc
db.iot.updateOne({ "sensor": r.sensor, "date": r.date,
                   "valcount": { "$lt": 48 } },
                         { "$push": { "readings": { "v": r.value, "t": r.time } },
                        "$inc": { "valcount": 1, "total": r.value } },
                 { "upsert": true })


// When upsert is set to true and the query predicate returns an empty cursor, 
// the update operation creates a new document using the directive 
// from the query predicate and the update predicate.

// By default upsert is set to false.

// When upsert is set to false and the query predicate returns an empty cursor 
// then there will be no updated documents as a result of this operation.

// ==== IDE ====

// Aggregation Framework

// 1. Using the aggregation framework find all documents that have Wifi as one
//    of the amenities. Only include price and address in the resulting cursor.
use("sample_airbnb")

db.listingsAndReviews.aggregate([
    {$match: {"amenities":"Wifi"}},
    {$project: {"price":1, "address":1, "_id":0}}
])

// 2. Which countries have listings in the sample_airbnb database?
use("sample_airbnb")

db.listingsAndReviews.aggregate([ 
    { "$project": { "address": 1, "_id": 0 }},
    { "$group": { "_id": "$address.country" }}
]).count()



// 3. How many countries have listings in the sample_airbnb database?
use("sample_airbnb")
db.listingsAndReviews.aggregate([ 
    { "$group": { "_id": "$address.country"}},
    { "$group": { "_id":1 , count:{$sum: 1}}}
])

// sort() and limit()

// 1. Find the least populated ZIP code in the zips collection.
use("sample_training")
db.zips.find().sort({"pop":1}).limit(1)

// 2. Find the most populated ZIP code in the zips collection.
use("sample_training")
db.zips.find().sort({"pop":-1}).limit(1)

// 3. Find the top ten most populated ZIP codes.
use("sample_training")
db.zips.find().sort({"pop":-1}).limit(10)

// 4. Get results sorted in increasing order by population, and decreasing
//    order by city name.
use("sample_training")
db.zips.find().sort({"pop":1,"city":-1}).limit(10)

// Introduction to Indexes

// Create two separate indxes to support the following queries:

// db.trips.find({"birth year": 1989})
use("sample_training")
db.trips.createIndex({"birth year":1})

// db.trips.find({"start station id": 476}).sort("birth year": 1)
use("sample_training")
db.trips.createIndex({"start station id":1, "birth year":1})


// ==== quizz Aggregation Framework

// What room types are present in the sample_airbnb.listingsAndReviews
// collection?
use("sample_airbnb")
db.listingsAndReviews.aggregate([
    {"$group":{"_id":"$room_type"}},
])

// sort() and limit()

// In what year was the youngest bike rider from the sample_training.trips
// collection born?
use("sample_training")
db.trips.find({ "birth year": { "$ne":"" } },
              { "birth year": 1 , "_id":0 }).sort({ "birth year": -1 }).limit(1)

